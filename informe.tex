\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\begin{document}
\title{TLA+}
\author{Anna Aimeri, Sebastián Giraudo, Valentín Negrelli}
\institute{Facultad de Matemática, Astronomía, Física y Computación, Av. Medina Allende s/n, Córdoba, Argentina}
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The abstract should briefly summarize the contents of the paper in
150--250 words.
\end{abstract}

\section{Introducción}
La complejidad de un sistema tiene incidencia directa en la probabilidad de agregar errores en el diseño y codificación del sistema a implementar, los cuales pueden derivar en pérdida o corrupción de la información, o en violación de contratos con interfaces externas. Es así como la necesidad de tener un nivel de confianza máximo en el comportamiento en tiempo real del sistema se vuelve de vital importancia, haciendo necesarias pero insuficientes las técnicas de verificación de software estándar, tales como revisiones de código, testing de diseño, análisis de código estático, testing por estrés, por inyección de fallas, entre otros. 

Es en este contexto que surgen el chequeo de modelado y las pruebas sobre especificaciones como recursos útiles para medir corrección, completitud, progreso, y otras características deseables de un sistema, al analizar automáticamente todas las ejecuciones posibles de un sistema complejo.

En el presente trabajo se desarrollarán las herramientas de verificación sobre el lenguaje de especificación TLA+ (Temporal Logic of Actions), en particular del model-checker TLC y el sistema de pruebas TLA+ Proof System, sus objetivos, los aspectos técnicos de su funcionamiento, y casos de estudio que utilizaron estas herramientas en la industria junto con los resultados que arrojaron.


\section{Contexto de creación}

\section{Objetivo}
TLA+ es un lenguaje de especificación formal multi-propósito particularmente útil para describir sistemas distribuidos y concurrentes. Se trata de un lenguaje declarativo, jerárquico, y escalable a especificaciones de grandes sistemas, que provee una abstracción consistente sobre varios verificadores como backend. 
Las propiedades que TLA+ puede chequear son condiciones sobre ejecuciones individuales. Además permite verificar invariantes sobre comportamientos válidos tales como fairness y algunas propiedades de lógica temporal básica que respondan a características de safety y liveness.

Dado que el objetivo de la herramienta es especificar propiedades sobre las variables libres del modelo, es utilizado principalmente en la etapa de arquitectura y diseño del software, una vez que se cuenta con la especificación y antes de codificar la implementación. A su vez, es posible apoyarse en la herramienta para derivar casos de tests, dado que un diseño certero del modelo nos provee el conjunto de propiedades a verificar para nuestra implementación.

\section{Descripción del lado del usuario}
El entorno de desarrollo integrado (IDE) para las herramientas de TLA+ es TLA Toolbox, y puede utilizarse para diseñar las especificaciones, correr el model checker (TLC) y el TLA Proof System (TLAPS). Además, es posible correr el model checker vía línea de comandos o a través de una extensión para Visual Studio Code, que cuenta con las funcionalidades básicas del IDE.

El lenguaje de especificación de modelos TLA+ es un lenguaje formal que combina la lógica matemática con la teoría de conjuntos. Las especificaciones se disponen en módulos que describen el comportamiento global del sistema, expresando propiedades que deben mantenerse a lo largo del tiempo. Estos módulos contienen variables que representan los estados del sistema, descritos mediante expresiones lógicas. Además, pueden contener constantes, definiciones de operadores, teoremas y aseveraciones. En el contexto del lenguaje, las acciones describen las transiciones entre estados, y se definen con expresiones lógicas que relacionan el estado actual con su sucesor.

El lenguaje de propiedades de TLA+ se basa en la lógica de acciones temporales (TLA). Esta lógica combina la lógica temporal con una lógica de acciones, proporcionando constructores que incluyen predicados sobre estados iniciales, relaciones de transición entre estados sucesivos y condiciones de fairness para garantizar un progreso adecuado en el sistema.

TLA+ permite realizar un análisis exhaustivo de propiedades críticas, como la detección de deadlocks, y el análisis de progreso, garantizando que el sistema avance hacia estados deseados. Además, TLA+ facilita la verificación de invariantes, propiedades que deben mantenerse verdaderas en todos los estados alcanzables del sistema, a través de fórmulas especificadas en los archivos de configuración. También permite el control de fairness, mediante la conjunción de fórmulas temporales que definen las condiciones de liveness del sistema. Los análisis se realizan evaluando predicados de estado inicial y acciones de siguiente estado especificadas, utilizando evaluaciones para eliminar posibles transiciones o estados, garantizando una revisión completa y precisa del comportamiento del sistema bajo diferentes condiciones. Además, es posible con TLA+ formular teoremas y diseñar pruebas formales de estos en TLAPS. (\textbf{AGREGAR MAS SOBRE TLAPS)}

Los modelos en TLA+ y su verificación en TLC ponen su foco en el comportamiento del sistema, abstrayéndose de los detalles de su implementación. Es por esto que son independientes de cualquier lenguaje de programación, y no es necesario anotar el programa. Sin embargo, es posible anotar el algoritmo usando el pseudo-código PlusCal, un lenguaje formal que se transpila a TLA+. A diferencia del enfoque orientado a acciones, PlusCal se asemeja más a un lenguaje de programación imperativo y es más adecuado para especificar algoritmos secuenciales.

TLC visualiza los errores en las especificaciones de TLA+ proporcionando informes detallados cuando encuentra la violación de alguna propiedad. Cuando TLC detecta que una de las propiedades que está verificando no se cumple, procede a reportar un contraejemplo que ilustra cómo el sistema llega a un estado en el que esa propiedad es violada. A continuación, TLC genera una traza que lleva al estado donde se produce la violación, representando cada estado como un predicado TLA+ que describe sus condiciones, y permite visualizar la evolución del sistema hasta llegar al estado problemático. Esta traza se minimiza para ofrecer una representación concisa pero informativa del problema. 

Los errores más difíciles de localizar son aquellos que TLC detecta al evaluar una expresión que no puede manejar o que produce un resultado no válido según la semántica de TLA+. TLC imprime la ubicación del error, indicando las expresiones anidadas que estaban siendo evaluadas cuando ocurrió el problema. A menudo, el reporte del error no es tan específico como se desearía, por lo que a veces es necesario insertar expresiones de impresión adicionales para localizar el problema con mayor precisión.

El verificador de modelos TLC permite la simulación de comportamientos del sistema. En modo de simulación, TLC construye y verifica repetidamente comportamientos individuales con una longitud máxima fija.
Para crear y verificar un comportamiento, TLC sigue un procedimiento similar al de construir el grafo G (\textbf{CUIDADO:} Acá hablamos del “grafo g” antes de definirlo), pero con una diferencia clave; después de calcular el conjunto de estados iniciales y el conjunto de sucesores para un estado dado, TLC elige pseudo-aleatoriamente un elemento de ese conjunto. Si el elemento no cumple con la restricción especificada, TLC detiene la computación de G. De lo contrario, TLC incluye ese estado en G y verifica las fórmulas de invarianza para ese estado. La construcción de G se detiene cuando se genera el número máximo especificado de estados.

\section{Aspectos técnicos}
TLC representa el espacio de estado de manera explícita utilizando un grafo dirigido G cuyos nodos son los estados del sistema. Este grafo es una parte del grafo de alcanzabilidad del estado que TLC ha encontrado hasta el momento. Además, TLC mantiene una cola U de estados que aún no han sido visitados o cuyos sucesores aún no han sido calculados.

El model checker utiliza Breadth First Search para explorar los estados alcanzables de un sistema y verificar que cumplen con las invariantes especificadas. Comienza evaluando los supuestos y calculando los estados iniciales. A partir de estos estados, TLC los añade a una cola y un grafo si cumplen con las restricciones iniciales. Este método garantiza que todos los estados alcanzables se examinen sistemáticamente. Si TLC encuentra un estado sin sucesores posibles reporta un estado de deadlock, indicando que el sistema no puede progresar más desde ese punto.

TLC no considera todo el espacio de estado, sino una parte de él. Utiliza una técnica de exploración exhaustiva, pero debido a limitaciones computacionales, de tiempo y de memoria, no es posible examinar todos los posibles estados de un sistema. En su lugar, TLC emplea estrategias inteligentes para explorar una porción representativa y significativa del espacio de estados, con el objetivo de detectar posibles problemas o violaciones de propiedades específicas en el modelo. Estas estrategias incluyen la generación de estados de manera incremental, el uso de técnicas de reducción como la simetría, y la exploración de estados que sean relevantes para las propiedades que se están verificando. De esta manera, TLC busca equilibrar la exhaustividad de la verificación con la eficiencia computacional, permitiendo obtener resultados significativos en un tiempo razonable.

En el contexto de TLA+, la simetría se aprovecha para reducir el número de estados que TLC necesita examinar al verificar una especificación. Si una especificación es simétrica con respecto a una permutación $\pi$, esto significa que si una secuencia de estados $\sigma$ satisface la especificación, entonces cualquier permutación de esa secuencia, $\sigma\pi$, también lo hará. Por lo tanto, si TLC ya ha verificado un comportamiento $\sigma$, no necesita verificar cualquier $\sigma\pi$ correspondiente, ya que cualquier error revelado por $\sigma$ también se revelaría por $\sigma\pi$.
Para aprovechar esta simetría, se puede incluir una declaración SYMMETRY en el archivo de configuración de TLC, definiendo un conjunto de permutaciones relevantes. Esto permite a TLC evitar agregar estados redundantes a su cola de estados no examinados y al grafo de estados si esos estados ya existen bajo alguna permutación.

En TLA+, se puede escribir una especificación de un programa que implementa una especificación más general mediante un mapeo de refinamiento adecuado. Este proceso implica mapear las variables de la especificación que se desea que el programa satisfaga con los estados de la especificación del programa en cuestión. El mapeo de refinamiento explica detalladamente cómo el programa cumple con la especificación general, lo que permite abstraer detalles específicos del programa y centrarse en su comportamiento general, asegurando que se cumplan las propiedades deseadas a nivel de especificación más alta.

\textbf{(FALTA RESPUESTA)}

En la verificación de modelos con TLC es posible que se generen falsos negativos, especialmente en el contexto de propiedades de liveness. Esto se debe a la dificultad de detectar violaciones de propiedades de liveness con modelos finitos, ya que estas propiedades requieren que el sistema alcance ciertos estados infinitas veces o en un orden específico, lo cual puede ser imposible de capturar con un modelo de estas características.

\textbf{(FALTA TLAPS)}

\section{Casos de estudio}


\noindent Displayed equations are centered and set on a separate
line.
\begin{equation}
x + y = z
\end{equation}

\begin{figure}
\caption{A figure caption is always placed below the illustration.
Please note that short captions are centered, while long ones are
justified by the macro package automatically.} \label{fig1}
\end{figure}

\begin{theorem}
This is a sample theorem. The run-in heading is set in bold, while
the following text appears in italics. Definitions, lemmas,
propositions, and corollaries are styled the same way.
\end{theorem}

For citations of references, we prefer the use of square brackets
and consecutive numbers. Citations using labels or the author/year
convention are also acceptable. The following bibliography provides
a sample reference list with entries for journal
articles~\cite{ref_article1}, an LNCS chapter~\cite{ref_lncs1}, a
book~\cite{ref_book1}, proceedings without editors~\cite{ref_proc1},
and a homepage. Multiple citations are grouped
\cite{ref_article1,ref_lncs1,ref_book1},
\cite{ref_article1,ref_book1,ref_proc1}.

\begin{thebibliography}{8}
\bibitem{ref_article1}
Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

\bibitem{ref_lncs1}
Author, F., Author, S.: Title of a proceedings paper. In: Editor,
F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
Springer, Heidelberg (2016). \doi{10.10007/1234567890}

\bibitem{ref_book1}
Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
Location (1999)

\bibitem{ref_proc1}
Author, A.-B.: Contribution title. In: 9th International Proceedings
on Proceedings, pp. 1--2. Publisher, Location (2010)

\end{thebibliography}
\end{document}
